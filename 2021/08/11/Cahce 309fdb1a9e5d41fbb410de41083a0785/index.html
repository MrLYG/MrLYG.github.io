<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Cache - Yuangang&#039;s Home</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Yuangang&#039;s Home"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Yuangang&#039;s Home"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Cache缓存意义万物皆有存在的意义，意义更多时候是弥补现有的不足。 Cache的意义在于弥补现有存储体系数据读写速度和CPU运行速度的鸿沟。简单来说就是CPU运算的速度远远快于从CPU从内存中读取数据的时间，添加缓存弥补时间上的差距，整体提高系统性能。 局部性原理何为局部性原理，局部性原理从何而来，他的意义是什么。我的理解是局部性原理是一种经验性的发现，一种结论，计算机的很多体系设置都是基于这个"><meta property="og:type" content="blog"><meta property="og:title" content="Cache"><meta property="og:url" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/"><meta property="og:site_name" content="Yuangang&#039;s Home"><meta property="og:description" content="Cache缓存意义万物皆有存在的意义，意义更多时候是弥补现有的不足。 Cache的意义在于弥补现有存储体系数据读写速度和CPU运行速度的鸿沟。简单来说就是CPU运算的速度远远快于从CPU从内存中读取数据的时间，添加缓存弥补时间上的差距，整体提高系统性能。 局部性原理何为局部性原理，局部性原理从何而来，他的意义是什么。我的理解是局部性原理是一种经验性的发现，一种结论，计算机的很多体系设置都是基于这个"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%201.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%202.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%203.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%204.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%205.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%206.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%207.png"><meta property="og:image" content="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%208.png"><meta property="article:published_time" content="2021-08-11T10:05:06.000Z"><meta property="article:modified_time" content="2021-08-11T10:25:58.326Z"><meta property="article:author" content="Yuangang Li"><meta property="article:tag" content="计算机组成"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/"},"headline":"Cache","image":["https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%201.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%202.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%203.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%204.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%205.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%206.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%207.png","https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%208.png"],"datePublished":"2021-08-11T10:05:06.000Z","dateModified":"2021-08-11T10:25:58.326Z","author":{"@type":"Person","name":"Yuangang Li"},"publisher":{"@type":"Organization","name":"Yuangang's Home","logo":{"@type":"ImageObject","url":"https://mrlyg.github.io/img/geek.svg"}},"description":"Cache缓存意义万物皆有存在的意义，意义更多时候是弥补现有的不足。 Cache的意义在于弥补现有存储体系数据读写速度和CPU运行速度的鸿沟。简单来说就是CPU运算的速度远远快于从CPU从内存中读取数据的时间，添加缓存弥补时间上的差距，整体提高系统性能。 局部性原理何为局部性原理，局部性原理从何而来，他的意义是什么。我的理解是局部性原理是一种经验性的发现，一种结论，计算机的很多体系设置都是基于这个"}</script><link rel="canonical" href="https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/geek.svg" alt="Yuangang&#039;s Home" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-08-11T10:05:06.000Z" title="2021/8/11 下午6:05:06">2021-08-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-11T10:25:58.326Z" title="2021/8/11 下午6:25:58">2021-08-11</time></span><span class="level-item">27 minutes read (About 4025 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Cache</h1><div class="content"><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h1 id="缓存意义"><a href="#缓存意义" class="headerlink" title="缓存意义"></a>缓存意义</h1><p>万物皆有存在的意义，意义更多时候是弥补现有的不足。 Cache的意义在于弥补现有存储体系数据读写速度和CPU运行速度的鸿沟。简单来说就是CPU运算的速度远远快于从CPU从内存中读取数据的时间，添加缓存弥补时间上的差距，整体提高系统性能。</p>
<h1 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h1><p>何为局部性原理，局部性原理从何而来，他的意义是什么。我的理解是局部性原理是一种经验性的发现，一种结论，计算机的很多体系设置都是基于这个发现的。</p>
<p>来看一下CSAPP上关于Locality的介绍</p>
<blockquote>
<p>Well-written computer programs tend to exhibit good locality. That is, they tend to reference data items that are near other recently referenced data items or that were recently referenced themselves. This tendency, known as the principle of locality, is an enduring concept that has  enormous impact on the design and performance of hardware and software systems.<br>一个编写良好的计算机程序常常具有良好的局部性(locality)。 也就是,它们倾向于引用邻近于其他最近引用过的数据项的数据项,或者最近引用过的数据项本身。这种倾向性,被称为局部性原理(principleof locality), 是一个持久的概念,对硬件和软件系统的设计和性能都有着极大的影响。</p>
</blockquote>
<p>Locality is  typically described as having two distinct forms: temporal locality and spatial locality. In a  program with good temporal locality, a memory location that is referenced once is likely to be referenced again multiple times in the near future. In a program with good spatial locality, if a memory location is referenced<br>局部性通常有两种不同的形式:时间局部性(temporal locality)和空间局部性(spalial locallty)。 在一个具有良好时间局部性的程序中,被引用过一次的内存位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中,如果一个内存位置被引用了一次,那么程序很可能在不远的将来引用附近的一个内存位置。</p>
<h2 id="什么是局部性"><a href="#什么是局部性" class="headerlink" title="什么是局部性"></a>什么是局部性</h2><p>局部性有两种形式</p>
<p><strong>1.时间局部性</strong></p>
<p>被引用过一次的位置未来会被多次引用</p>
<p><strong>2.空间局部性</strong></p>
<p>存储器中被某一数据的位置被引用，那么将来该位置附近的位置也会被引用</p>
<p>通过一个简单的CSAPP书上的例子解释一下，时间局部性和空间局部性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumvec</span><span class="params">(<span class="keyword">int</span> v[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	 sum += v[i];</span><br><span class="line">	 <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled.png"></p>
<p>如图数组v的元素是被顺序读取，所以对于变量v, 他有很好的空间局部性（因为在V0被引用以后，v0位置附近的位置也会被引用)，但数组变量v的时间局部性很差，因为v数组中每个数据只引用一次。变量sum有很好的的时间局部性，因为他被引用后会被多次引用。</p>
<p>具有良好局部性的代码，CPU在连续访问数据时，每次访问的数据的在存储空间位置上的步长更短，最好的情况就是被访问的数据时连续且依次被CPU访问的。</p>
<p>步长和缓存命中也有关系</p>
<h2 id="局部性原理和缓存的关系"><a href="#局部性原理和缓存的关系" class="headerlink" title="局部性原理和缓存的关系"></a>局部性原理和缓存的关系</h2><p>缓存的主要目的是为了解决CPU和一般存储器间速度的鸿沟，缓存<strong>符合</strong>局部性原理。</p>
<p>在计算机存储体系中上层存储器是下层存储器的缓存。下层存储器中的数据一旦被装入上层存储器，就很有可能被多次用到，此时CPU则可以在更靠近它的性能也更高的存储器内找到其需要的数据，而不需要每次都要到离它更远，性能也更低的存储器内去存取它们[1]。</p>
<p>设想我们很有钱买了一台所有存储器材料SRAM（寄存器所使用的材料，读写速度极快）的计算机，这样我们的CPU即使不需要缓存也能很快的去访问数据。但是仔细想一想这样是造成了极大的资源浪费的，因为在一个时刻，存储器中的数据只有一部分是被引用的（局部性原理），而存储器中其他的大部分数据都是空闲的，那么这些空闲的数据还是存到SRAM为材料的存储器中的话会很浪费资源。</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%201.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%201.png"></p>
<p><a href></a></p>
<p>在某一时刻，上图有色区域是CPU所要使用的数据，其他的位置都是空闲的，这样会有极大的浪费。———即使所有的数据直接存储到很大的寄存器中，但同一时刻，你可能只会用到其中的一部分。所以还不如用缓存架构。 总有些是正在工作，总有些是空闲的。缓存设计的理念就是将工作的数据抽出来，不工作的数据还留在原有的存储器中。</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%202.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%202.png"></p>
<p>如上图，简单抽象缓存的设计思路（实际上要复杂很多），某一进程启动时先将将磁盘的数据先加载到内存中，在将数据加载到缓存中。</p>
<p>这样的好处 1.解决了CPU运算很快，数据读写很慢的情况。 2.因为读写越快的存储器越贵，将工作的数据抽到缓存中，暂时不工作的数据存放在稍便宜的但读写偏慢的存储器中（内存），将资源性文件，例如一个视频文档等，在不用的时候放到磁盘中，这样资源的利用率高。</p>
<h1 id="数据分块的概念"><a href="#数据分块的概念" class="headerlink" title="数据分块的概念"></a>数据分块的概念</h1><p>知道了为何有缓存以及缓存的设计理念后，我们可以想到把CPU目前访问的地址和周围的部分数据放到缓存中会极大的提高程序效率。</p>
<p>这就引出了数据分块的概念，将内存的存储空间进行“分块”，主存于缓存Cache之间以“块”为单位进行数据交换。</p>
<p>Core i7中所有cache的块大小都是64B[2]</p>
<p>为了更好地理解，内存的大小为8MB，Cache大小为8KB（具体如图所示）</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%203.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%203.png"></p>
<p>由此我们来思考几个问题：1.内存的块和Cache的块如何对应呢？ 2. 因为Cache的存储容量是远小于内存容量的，那么Cache容量满了之后应该如何处理呢？3.CPU修改Cache中的数据后，如何同步到内存中，以及在并发场景下如何保证数据的一致性呢？</p>
<h1 id="Cache和内存的3种映射关系"><a href="#Cache和内存的3种映射关系" class="headerlink" title="Cache和内存的3种映射关系"></a>Cache和内存的3种映射关系</h1><p>CPU根据地址寻找数据时总是先在缓存中寻找，在缓存中没有找到（缓存未命中）后才会去内存寻找，然后，根据局部性原理，把CPU所寻找的数据所在位置的数据块加载到缓存，使CPU在下次寻找数据时直接能在缓存中找到。</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%204.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%204.png"></p>
<p>还是以内存的大小为8MB，Cache大小为8KB为例—- cahce和内存的映射关系</p>
<h2 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h2><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><h2 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h2><h1 id="Cache中数据的替换算法"><a href="#Cache中数据的替换算法" class="headerlink" title="Cache中数据的替换算法"></a>Cache中数据的替换算法</h1><p>cache 满了怎么办   —替换算法</p>
<p>有四种方法分别是</p>
<ul>
<li>随机算法(RAND)</li>
<li>先进先出算法(FIFO)</li>
<li>近期最少使用算法(LRU 面试高频)</li>
<li>最近不经常使用算法(LFU)</li>
</ul>
<h2 id="随机算法-RAND"><a href="#随机算法-RAND" class="headerlink" title="随机算法(RAND)"></a>随机算法(RAND)</h2><p>随机算法（RAND, Random）——若Cache已满，则随机选择一块替换。</p>
<p>实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定</p>
<h2 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h2><p>先进先出算法（FIFO, First In First Out）——若Cache已满，则替换最先被调入Cache 的块</p>
<p>先进先出算法——实现简单，最开始按#0#1#2#3放入Cache，之后轮流替换 #0#1#2#3<br>FIFO依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的</p>
<h2 id="✨近期最少使用算法-LRU"><a href="#✨近期最少使用算法-LRU" class="headerlink" title="✨近期最少使用算法(LRU)"></a>✨近期最少使用算法(LRU)</h2><p>近期最少使用算法（LRU, Least Recently Used ）—— 为每一个Cache块设置一个“计数器”，用于记录<br>每个Cache块已经有多久没被访问了。当<strong>Cache满后替换“计数器”最大的</strong></p>
<h3 id="LRU实现过程"><a href="#LRU实现过程" class="headerlink" title="LRU实现过程"></a>LRU实现过程</h3><p>①命中时，所命中的行的计数器清零，<strong>比其低的计数器加1，其余不变 → 当一个Cache有2^n个数据块时，计数器只需要n位当数据满时，加入新的数据块，计数器的值一定是不重复的。</strong><br>②未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；<br>③未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。</p>
<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34989978">缓存淘汰算法–LRU算法</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038714624">其实吧，LRU也就那么回事。</a></p>
<p>自己实现了一个读数据和插入数据以及删除数据都为O(1)的数据结构，是HashMap和链表的结合，HashMap优化查询，链表优化插入和删除。Java有自带的LinkedHashMap的库；</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%205.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%205.png"></p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/MrLYG/38f0a461c24fefcb4dbea26e3e32f537">https://gist.github.com/MrLYG/38f0a461c24fefcb4dbea26e3e32f537</a></p>
<p><a target="_blank" rel="noopener" href="https://replit.com/@kenli5/StudyJavaToMaster#LeetCode/src/main/java/LRU/LRUCache.java">https://replit.com/@kenli5/StudyJavaToMaster#LeetCode/src/main/java/LRU/LRUCache.java</a></p>
<h3 id="LRU-Pros-amp-Cons"><a href="#LRU-Pros-amp-Cons" class="headerlink" title="LRU Pros&amp;Cons"></a>LRU Pros&amp;Cons</h3><p><strong>pros</strong>→LRU算法——基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，Cache命中率高。</p>
<p><strong>cons</strong>→若被频繁访问的主存块数量 &gt; Cache行的数量，则有可能发生“<strong>抖动</strong>”，如：{1,2,3,4,5,1,2,3,4,5,1,2…} cache 只有四组的情况</p>
<p>解释一下： 当cache只有四组的情况时</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%206.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%206.png"></p>
<p>如图：红色代表当次访问的到数据块从内存加载到了cache中</p>
<p>可以发现在这种情况中，LRU算法退化成了FIFO算法，导致效率低下，且缓存命中率为0，跟没加缓存的性能一样。所以如果出现程序突然的运行效率变低，需要注意是否是出现抖动的情况；</p>
<p><strong>如何修复抖动情况</strong>：</p>
<p>避免CPU访问5号位的数据。</p>
<p>相信大家看到这里，跟我第一次学的时候一样的懵B无措，希望大家带着问题继续往下看，下面将讲解到底什么是“抖动”。</p>
<h3 id="抖动-thrash"><a href="#抖动-thrash" class="headerlink" title="抖动(thrash)"></a>抖动(thrash)</h3><p>The term thrashing describes any situation where a cache is repeatedly loading and evicting the same sets of cache blocks.<br>术语“抖动”描述了一种情况，即高速缓存重复的加载和删除相同的高速缓存块组</p>
<p>eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dotprod</span><span class="params">(<span class="keyword">float</span> x [<span class="number">8</span>], <span class="keyword">float</span> y [<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	  sum += x [i] * y [i];</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Suppose that floats are 4 bytes, that x is loaded into the 32 bytes of contiguous memory starting at address 0, and that y starts immediately after x at address 32. For simplicity, suppose that a block is 16 bytes (big enough to hold four floats) and that the cache consists of two sets, for a total cache size of 32 bytes. We will assume that the variable sum is actually stored in a CPU register and thus does not require a memory reference. Given these assumptions, each x[i] and y[i] will map to the identical cache set:</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%207.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%207.png"></p>
<p>At run time, the first iteration of the loop references x[0] , a miss that causes the block containing x[0]−x [3] to be loaded into set 0. The next reference is to y[0] , another miss that causes the block containing y [0]−y [3] to be copied into set 0, overwriting the values of x that were copied in by the previous reference. During the next iteration, the reference to x[1] misses, which causes the x[0]−x [3] block to be loaded back into set 0, overwriting the y[0]−y[3] block. So now we have a conflict miss, and in fact each subsequent reference to x and y will result in a conflict miss as we thrash back and forth between blocks of x and y . The term thrashing describes any situation where a cache is repeatedly loading and evicting the same sets of cache blocks.</p>
<p>The bottom line is that even though the program has good spatial locality and we have room in the cache to hold the blocks for both x[i] and y[i] , each reference results in a conflict miss because the blocks map to  the same cache set. It is not unusual for this kind of thrashing to result in a  slowdown by a factor of 2 or 3. Also, be aware that even though our example is extremely simple, the problem is real for larger and more realistic direct-mapped caches. Luckily, thrashing is easy for programmers to fix once they recognize what is going on. One easy solution is to put B bytes of padding at the end of each array. For example, instead of defining x to be float x[8] , we define it to be float x[12] . Assuming y starts immediately after x in memory, we have the following mapping of array elements to sets:</p>
<p><img src="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%208.png" alt="Cahce%20309fdb1a9e5d41fbb410de41083a0785/Untitled%208.png"></p>
<p>With the padding at the end of x, x[i] and y[i] now map to different sets, which eliminates the thrashing conflict misses.</p>
<h2 id="最近不经常使用算法-LFU"><a href="#最近不经常使用算法-LFU" class="headerlink" title="最近不经常使用算法(LFU)"></a>最近不经常使用算法(LFU)</h2><p>最不经常使用算法（LFU, Least Frequently Used ）—— 为每一个Cache块设置一个“计数器”，用于记<br>录每个Cache块被访问过几次。当Cache满后替换“计数器”最小的</p>
<p>LFU算法——曾经被经常访问的主存块在未来不一定会用到（如：微信视频聊天相关的块），<br>并没有很好地遵循局部性原理，因此实际运行效果不如 LRU</p>
<h1 id="写操作如何确保数据的一致性"><a href="#写操作如何确保数据的一致性" class="headerlink" title="写操作如何确保数据的一致性"></a>写操作如何确保数据的一致性</h1><h2 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h2><h3 id="写回法-write-back"><a href="#写回法-write-back" class="headerlink" title="写回法(write-back)"></a>写回法(write-back)</h3><p>— 当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存</p>
<p>减少了访存次数，但存在数据不一致的隐患。</p>
<h3 id="全写法-写直通法，write-through"><a href="#全写法-写直通法，write-through" class="headerlink" title="全写法(写直通法，write-through)"></a>全写法(写直通法，write-through)</h3><p>当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲(write buffer)</p>
<p>访存次数增加，速度变慢，但更能保证数据一致性；</p>
<p>使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会<br>因为写缓冲饱和而发生阻塞</p>
<h2 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h2><h3 id="写分配法-write-allocate"><a href="#写分配法-write-allocate" class="headerlink" title="写分配法(write-allocate)"></a>写分配法(write-allocate)</h3><p>当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配写回法使用。</p>
<h3 id="非写分配法-not-write-allocate"><a href="#非写分配法-not-write-allocate" class="headerlink" title="非写分配法(not-write-allocate)"></a>非写分配法(not-write-allocate)</h3><p>当CPU对Cache写不命中时只写入主存，不调入Cache。搭配全写法使用。</p>
<h2 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h2><p>各级Cache之间常采用“全写法+非写分配法”</p>
<p>Cache和主存之间采用“写回发+写分配法”</p>
<p>缓存命中</p>
<h1 id="借鉴内容"><a href="#借鉴内容" class="headerlink" title="借鉴内容"></a>借鉴内容</h1><p>[1]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/feng9exe/p/6882414.html">https://www.cnblogs.com/feng9exe/p/6882414.html</a></p>
<p>[2]<a target="_blank" rel="noopener" href="https://www.huaweicloud.com/zhishi/arc-9558555.html">https://www.huaweicloud.com/zhishi/arc-9558555.html</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Cache</p><p><a href="https://mrlyg.github.io/2021/08/11/Cahce 309fdb1a9e5d41fbb410de41083a0785/">https://mrlyg.github.io/2021/08/11/Cahce 309fdb1a9e5d41fbb410de41083a0785/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuangang Li</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-08-11</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-08-11</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/11/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%20df4a3ea1a0ce48f9a179b09dafc9a32d/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">内存空间的分配与回收</span></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://mrlyg.github.io/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/';
            this.page.identifier = '2021/08/11/Cahce 309fdb1a9e5d41fbb410de41083a0785/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'ken' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Li YuanGang"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Li YuanGang</p><p class="is-size-6 is-block">Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrLYG" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrLYG"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-11T10:05:06.000Z">2021-08-11</time></p><p class="title"><a href="/2021/08/11/hello/">hello</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-11T10:05:06.000Z">2021-08-11</time></p><p class="title"><a href="/2021/08/11/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%20df4a3ea1a0ce48f9a179b09dafc9a32d/">内存空间的分配与回收</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-11T10:05:06.000Z">2021-08-11</time></p><p class="title"><a href="/2021/08/11/Cahce%20309fdb1a9e5d41fbb410de41083a0785/">Cache</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"><span class="tag">计算机组成</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Cache"><span class="level-left"><span class="level-item">1</span><span class="level-item">Cache</span></span></a></li><li><a class="level is-mobile" href="#缓存意义"><span class="level-left"><span class="level-item">2</span><span class="level-item">缓存意义</span></span></a></li><li><a class="level is-mobile" href="#局部性原理"><span class="level-left"><span class="level-item">3</span><span class="level-item">局部性原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是局部性"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">什么是局部性</span></span></a></li><li><a class="level is-mobile" href="#局部性原理和缓存的关系"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">局部性原理和缓存的关系</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据分块的概念"><span class="level-left"><span class="level-item">4</span><span class="level-item">数据分块的概念</span></span></a></li><li><a class="level is-mobile" href="#Cache和内存的3种映射关系"><span class="level-left"><span class="level-item">5</span><span class="level-item">Cache和内存的3种映射关系</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#全相联映射"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">全相联映射</span></span></a></li><li><a class="level is-mobile" href="#直接映射"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">直接映射</span></span></a></li><li><a class="level is-mobile" href="#组相联映射"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">组相联映射</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Cache中数据的替换算法"><span class="level-left"><span class="level-item">6</span><span class="level-item">Cache中数据的替换算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#随机算法-RAND"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">随机算法(RAND)</span></span></a></li><li><a class="level is-mobile" href="#先进先出算法-FIFO"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">先进先出算法(FIFO)</span></span></a></li><li><a class="level is-mobile" href="#✨近期最少使用算法-LRU"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">✨近期最少使用算法(LRU)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#LRU实现过程"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">LRU实现过程</span></span></a></li><li><a class="level is-mobile" href="#LRU算法"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">LRU算法</span></span></a></li><li><a class="level is-mobile" href="#LRU-Pros-amp-Cons"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">LRU Pros&amp;Cons</span></span></a></li><li><a class="level is-mobile" href="#抖动-thrash"><span class="level-left"><span class="level-item">6.3.4</span><span class="level-item">抖动(thrash)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最近不经常使用算法-LFU"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">最近不经常使用算法(LFU)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#写操作如何确保数据的一致性"><span class="level-left"><span class="level-item">7</span><span class="level-item">写操作如何确保数据的一致性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#写命中"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">写命中</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#写回法-write-back"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">写回法(write-back)</span></span></a></li><li><a class="level is-mobile" href="#全写法-写直通法，write-through"><span class="level-left"><span class="level-item">7.1.2</span><span class="level-item">全写法(写直通法，write-through)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#写不命中"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">写不命中</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#写分配法-write-allocate"><span class="level-left"><span class="level-item">7.2.1</span><span class="level-item">写分配法(write-allocate)</span></span></a></li><li><a class="level is-mobile" href="#非写分配法-not-write-allocate"><span class="level-left"><span class="level-item">7.2.2</span><span class="level-item">非写分配法(not-write-allocate)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多级Cache"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">多级Cache</span></span></a></li></ul></li><li><a class="level is-mobile" href="#借鉴内容"><span class="level-left"><span class="level-item">8</span><span class="level-item">借鉴内容</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/geek.svg" alt="Yuangang&#039;s Home" height="28"></a><p class="is-size-7"><span>&copy; 2021 Yuangang Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>